ED25519 INFORMATION:

5.1.5.  Key Generation

   The private key is 32 octets (256 bits, corresponding to b) of
   cryptographically secure random data.  See [RFC4086] for a discussion
   about randomness.

   The 32-byte public key is generated by the following steps.

   1.  Hash the 32-byte private key using SHA-512, storing the digest in
       a 64-octet large buffer, denoted h.  Only the lower 32 bytes are
       used for generating the public key.

   2.  Prune the buffer: The lowest three bits of the first octet are
       cleared, the highest bit of the last octet is cleared, and the
       second highest bit of the last octet is set.

   3.  Interpret the buffer as the little-endian integer, forming a
       secret scalar s.  Perform a fixed-base scalar multiplication
       [s]B.

   4.  The public key A is the encoding of the point [s]B.  First,
       encode the y-coordinate (in the range 0 <= y < p) as a little-
       endian string of 32 octets.  The most significant bit of the
       final octet is always zero.  To form the encoding of the point
       [s]B, copy the least significant bit of the x coordinate to the
       most significant bit of the final octet.  The result is the
       public key.


5.1.6.  Sign

   The inputs to the signing procedure is the private key, a 32-octet
   string, and a message M of arbitrary size.  For Ed25519ctx and
   Ed25519ph, there is additionally a context C of at most 255 octets
   and a flag F, 0 for Ed25519ctx and 1 for Ed25519ph.

   1.  Hash the private key, 32 octets, using SHA-512.  Let h denote the
       resulting digest.  Construct the secret scalar s from the first
       half of the digest, and the corresponding public key A, as
       described in the previous section.  Let prefix denote the second
       half of the hash digest, h[32],...,h[63].

   2.  Compute SHA-512(dom2(F, C) || prefix || PH(M)), where M is the
       message to be signed.  Interpret the 64-octet digest as a little-
       endian integer r.

   3.  Compute the point [r]B.  For efficiency, do this by first
       reducing r modulo L, the group order of B.  Let the string R be
       the encoding of this point.

   4.  Compute SHA512(dom2(F, C) || R || A || PH(M)), and interpret the
       64-octet digest as a little-endian integer k.

   5.  Compute S = (r + k * s) mod L.  For efficiency, again reduce k
       modulo L first.

   6.  Form the signature of the concatenation of R (32 octets) and the
       little-endian encoding of S (32 octets; the three most
       significant bits of the final octet are always zero).


5.1.7.  Verify

   1.  To verify a signature on a message M using public key A, with F
       being 0 for Ed25519ctx, 1 for Ed25519ph, and if Ed25519ctx or
       Ed25519ph is being used, C being the context, first split the
       signature into two 32-octet halves.  Decode the first half as a
       point R, and the second half as an integer S, in the range
       0 <= s < L.  Decode the public key A as point A'.  If any of the
       decodings fail (including S being out of range), the signature is
       invalid.

   2.  Compute SHA512(dom2(F, C) || R || A || PH(M)), and interpret the
       64-octet digest as a little-endian integer k.

   3.  Check the group equation [8][S]B = [8]R + [8][k]A'.  It's
       sufficient, but not required, to instead check [S]B = R + [k]A'.


   +-----------+-------------------------------------------------------+
   | Parameter | Value                                                 |
   +-----------+-------------------------------------------------------+
   |     p     | p of edwards25519 in [RFC7748] (i.e., 2^255 - 19)     |
   |     b     | 256                                                   |
   |  encoding | 255-bit little-endian encoding of {0, 1, ..., p-1}    |
   |  of GF(p) |                                                       |
   |    H(x)   | SHA-512(dom2(phflag,context)||x) [RFC6234]            |
   |     c     | base 2 logarithm of cofactor of edwards25519 in       |
   |           | [RFC7748] (i.e., 3)                                   |
   |     n     | 254                                                   |
   |     d     | d of edwards25519 in [RFC7748] (i.e., -121665/121666  |
   |           | = 370957059346694393431380835087545651895421138798432 |
   |           | 19016388785533085940283555)                           |
   |     a     | -1                                                    |
   |     B     | (X(P),Y(P)) of edwards25519 in [RFC7748] (i.e., (1511 |
   |           | 22213495354007725011514095885315114540126930418572060 |
   |           | 46113283949847762202, 4631683569492647816942839400347 |
   |           | 5163141307993866256225615783033603165251855960))      |
   |     L     | order of edwards25519 in [RFC7748] (i.e.,             |
   |           | 2^252+27742317777372353535851937790883648493).        |
   |   PH(x)   | x (i.e., the identity function)                       |
   +-----------+-------------------------------------------------------+


B:
X:	15112221349535400772501151409588531511454012693041857206046113283949847762202
	2169 36D3 CD6E 53FE C0A4 E231 FDD6 DC5C 692C C760 9525 A7B2 C956 2D60 8F25 D51A
	2169 36d3 cd6e 53fe c0a4 e231 fdd6 dc5c 692c c760 9525 a7b2 c956 2d60 8f25 d51a

Y:	46316835694926478169428394003475163141307993866256225615783033603165251855960
	6666 6666 6666 6666 6666 6666 6666 6666 6666 6666 6666 6666 6666 6666 6666 6658

T:	6787 5F0F D78B 7665 66EA 4E8E 64AB E37D 20F0 9F80 7751 52F5 6DDE 8AB3 A5B7 DDA3
	6787 5f0f d78b 7665 66ea 4e8e 64ab e37d 20f0 9f80 7751 52f5 6dde 8ab3 a5b7 dda3


5.1.1.  Modular Arithmetic

   For advice on how to implement arithmetic modulo p = 2^255 - 19
   efficiently and securely, see Curve25519 [CURVE25519].  For inversion
   modulo p, it is recommended to use the identity x^-1 = x^(p-2) (mod
   p).  Inverting zero should never happen, as it would require invalid
   input, which would have been detected before, or would be a
   calculation error.

   For point decoding or "decompression", square roots modulo p are
   needed.  They can be computed using the Tonelli-Shanks algorithm or
   the special case for p = 5 (mod 8).  To find a square root of a,
   first compute the candidate root x = a^((p+3)/8) (mod p).  Then there
   are three cases:

      x^2 = a (mod p).  Then x is a square root.

      x^2 = -a (mod p).  Then 2^((p-1)/4) * x is a square root.

      a is not a square modulo p.


5.1.2.  Encoding

   All values are coded as octet strings, and integers are coded using
   little-endian convention, i.e., a 32-octet string h h[0],...h[31]
   represents the integer h[0] + 2^8 * h[1] + ... + 2^248 * h[31].

   A curve point (x,y), with coordinates in the range 0 <= x,y < p, is
   coded as follows.  First, encode the y-coordinate as a little-endian
   string of 32 octets.  The most significant bit of the final octet is
   always zero.  To form the encoding of the point, copy the least
   significant bit of the x-coordinate to the most significant bit of
   the final octet.


5.1.3.  Decoding

   Decoding a point, given as a 32-octet string, is a little more
   complicated.

   1.  First, interpret the string as an integer in little-endian
       representation.  Bit 255 of this number is the least significant
       bit of the x-coordinate and denote this value x_0.  The
       y-coordinate is recovered simply by clearing this bit.  If the
       resulting value is >= p, decoding fails.

   2.  To recover the x-coordinate, the curve equation implies
       x^2 = (y^2 - 1) / (d y^2 + 1) (mod p).  The denominator is always
       non-zero mod p.  Let u = y^2 - 1 and v = d y^2 + 1.  To compute
       the square root of (u/v), the first step is to compute the
       candidate root x = (u/v)^((p+3)/8).  This can be done with the
       following trick, using a single modular powering for both the
       inversion of v and the square root:

                          (p+3)/8      3        (p-5)/8
                 x = (u/v)        = u v  (u v^7)         (mod p)

   3.  Again, there are three cases:

       1.  If v x^2 = u (mod p), x is a square root.

       2.  If v x^2 = -u (mod p), set x <-- x * 2^((p-1)/4), which is a
           square root.

       3.  Otherwise, no square root exists for modulo p, and decoding
           fails.

   4.  Finally, use the x_0 bit to select the right square root.  If
       x = 0, and x_0 = 1, decoding fails.  Otherwise, if x_0 != x mod
       2, set x <-- p - x.  Return the decoded point (x,y).


5.1.4.  Point Addition

   For point addition, the following method is recommended.  A point
   (x,y) is represented in extended homogeneous coordinates (X, Y, Z,
   T), with x = X/Z, y = Y/Z, x * y = T/Z.

   The neutral point is (0,1), or equivalently in extended homogeneous
   coordinates (0, Z, Z, 0) for any non-zero Z.

   The following formulas for adding two points, (x3,y3) =
   (x1,y1)+(x2,y2), on twisted Edwards curves with a=-1, square a, and
   non-square d are described in Section 3.1 of [Edwards-revisited] and
   in [EFD-TWISTED-ADD].  They are complete, i.e., they work for any
   pair of valid input points.

                 A = (Y1-X1)*(Y2-X2)
                 B = (Y1+X1)*(Y2+X2)
                 C = T1*2*d*T2
                 D = Z1*2*Z2
                 E = B-A
                 F = D-C
                 G = D+C
                 H = B+A
                 X3 = E*F
                 Y3 = G*H
                 T3 = E*H
                 Z3 = F*G

   For point doubling, (x3,y3) = (x1,y1)+(x1,y1), one could just
   substitute equal points in the above (because of completeness, such
   substitution is valid) and observe that four multiplications turn
   into squares.  However, using the formulas described in Section 3.2
   of [Edwards-revisited] and in [EFD-TWISTED-DBL] saves a few smaller
   operations.

                 A = X1^2
                 B = Y1^2
                 C = 2*Z1^2
                 H = A+B
                 E = H-(X1+Y1)^2
                 G = A-B
                 F = C+G
                 X3 = E*F
                 Y3 = G*H
                 T3 = E*H
                 Z3 = F*G
