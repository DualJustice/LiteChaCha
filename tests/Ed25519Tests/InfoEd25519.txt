ED25519 INFORMATION:


# Base field Z_p
p = 2**255 - 19

def modp_inv(x):
    return pow(x, p-2, p)

# Curve constant
d = -121665 * modp_inv(121666) % p

# Group order
q = 2**252 + 27742317777372353535851937790883648493

def sha512_modq(s):
    return int.from_bytes(sha512(s), "little") % q


## Then follows functions to perform point operations.

# Points are represented as tuples (X, Y, Z, T) of extended
# coordinates, with x = X/Z, y = Y/Z, x*y = T/Z

def point_add(P, Q):
    A, B = (P[1]-P[0]) * (Q[1]-Q[0]) % p, (P[1]+P[0]) * (Q[1]+Q[0]) % p;
    C, D = 2 * P[3] * Q[3] * d % p, 2 * P[2] * Q[2] % p;
    E, F, G, H = B-A, D-C, D+C, B+A;
    return (E*F, G*H, F*G, E*H);

# Computes Q = s * Q
def point_mul(s, P):
    Q = (0, 1, 1, 0)  # Neutral element
    while s > 0:
        if s & 1:
            Q = point_add(Q, P)
        P = point_add(P, P)
        s >>= 1
    return Q

def point_equal(P, Q):
    # x1 / z1 == x2 / z2  <==>  x1 * z2 == x2 * z1
    if (P[0] * Q[2] - Q[0] * P[2]) % p != 0:
        return False
    if (P[1] * Q[2] - Q[1] * P[2]) % p != 0:
        return False
    return True


## Now follows functions for point compression.

# Square root of -1
modp_sqrt_m1 = pow(2, (p-1) // 4, p)

# Compute corresponding x-coordinate, with low bit corresponding to
# sign, or return None on failure
def recover_x(y, sign):
    if y >= p:
        return None
    x2 = (y*y-1) * modp_inv(d*y*y+1)
    if x2 == 0:
        if sign:
            return None
        else:
            return 0

    # Compute square root of x2
    x = pow(x2, (p+3) // 8, p)
    if (x*x - x2) % p != 0:
        x = x * modp_sqrt_m1 % p
    if (x*x - x2) % p != 0:
        return None

    if (x & 1) != sign:
        x = p - x
    return x

# Base point
g_y = 4 * modp_inv(5) % p
g_x = recover_x(g_y, 0)
G = (g_x, g_y, 1, g_x * g_y % p)

def point_compress(P):
    zinv = modp_inv(P[2])
    x = P[0] * zinv % p
    y = P[1] * zinv % p
    return int.to_bytes(y | ((x & 1) << 255), 32, "little")

def point_decompress(s):
    if len(s) != 32:
        raise Exception("Invalid input length for decompression")
    y = int.from_bytes(s, "little")
    sign = y >> 255
    y &= (1 << 255) - 1

    x = recover_x(y, sign)
    if x is None:
        return None
    else:
        return (x, y, 1, x*y % p)


## These are functions for manipulating the private key.

def secret_expand(secret):
    if len(secret) != 32:
        raise Exception("Bad size of private key")
    h = sha512(secret)
    sByte = int.from_bytes(h[:32], "little")
    sByte &= (1 << 254) - 8
    sByte |= (1 << 254)
    return (sByte, h[32:])

def secret_to_public(secret):
    (sByte, dummy) = secret_expand(secret)
    return point_compress(point_mul(sByte, G))


## The signature function works as below.

def sign(secret, msg):
    sByte, prefix = secret_expand(secret)
    A = point_compress(point_mul(sByte, G))
    r = sha512_modq(prefix + msg)
    R = point_mul(r, G)
    Rs = point_compress(R)
    h = sha512_modq(Rs + A + msg)
    s = (r + h * sByte) % q
    return Rs + int.to_bytes(s, 32, "little")


## And finally the verification function.

def verify(public, msg, signature):
    if len(public) != 32:
        raise Exception("Bad public key length")
    if len(signature) != 64:
        Exception("Bad signature length")
    A = point_decompress(public)
    if not A:
        return False
    Rs = signature[:32]
    R = point_decompress(Rs)
    if not R:
        return False
    s = int.from_bytes(signature[32:], "little")
    if s >= q: return False
    h = sha512_modq(Rs + public + msg)
    sB = point_mul(s, G)
    hA = point_mul(h, A)
    return point_equal(sB, point_add(R, hA))


-------------------- START HERE --------------------

			STEP ONE:

    	sByte, prefix = secret_expand(secret)

def secret_expand(secret):
    if len(secret) != 32:
        raise Exception("Bad size of private key")
    h = sha512(secret)
    sByte = int.from_bytes(h[:32], "little")
    sByte &= (1 << 254) - 8 (&= 3FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF8)
    sByte |= (1 << 254)
    return (sByte, h[32:])


			STEP TWO:

    	A = point_compress(point_mul(sByte, G))

def point_add(P, Q):
    A, B = (P[1]-P[0]) * (Q[1]-Q[0]) % p, (P[1]+P[0]) * (Q[1]+Q[0]) % p;
    C, D = 2 * P[3] * Q[3] * d % p, 2 * P[2] * Q[2] % p;
    E, F, G, H = B-A, D-C, D+C, B+A;
    return (E*F, G*H, F*G, E*H);

---------- MY OWN VERSION OF POINT ADD: ----------
def point_add(Q, P):
    A, B = (Q[1]-Q[0]) * (P[1]-P[0]) % p, (Q[1]+Q[0]) * (P[1]+P[0]) % p;
    C, D = 2 * Q[3] * P[3] * d % p, 2 * Q[2] * P[2] % p;
    E, F, G, H = B-A, D-C, D+C, B+A;
    return (E*F, G*H, F*G, E*H);

	A = (Q.Y - Q.X)*(P.Y - P.X) % p;
	B = (Q.Y + Q.X)*(P.Y + P.X) % p;
	C = 2 * Q.T * P.T * d % p;
	D = 2 * Q.Z * P.Z % p;
	E = B - A;
	F = D - C;
	G = D + C;
	H = B + A;
	outX = E*F;
	outY = G*H;
	outZ = F*G;
	outT = E*H;

	A = (Q.Y - Q.X);
	B = (P.Y - P.X);
	A = A*B;

	B = (Q.Y + Q.X);
	C = (P.Y + P.X);
	B = B*C;

	C = Q.T * 2d;
	C = C * P.T;

	D = 2 * Q.Z;
	D = D * P.Z;

	E = B - A;
	F = D - C;
	G = D + C;
	H = B + A;

	outX = E*F;
	outY = G*H;
	outZ = F*G;
	outT = E*H;
--------------------------------------------------

# Computes Q = s * Q
def point_mul(s, P):
    Q = (0, 1, 1, 0)  # Neutral element
    while s > 0:
        if s & 1:
            Q = point_add(Q, P)
        P = point_add(P, P)
        s >>= 1
    return Q

def modp_inv(x):
    return pow(x, p-2, p)

def point_compress(Q):
    zinv = modp_inv(Q[2])
    x = Q[0] * zinv % p
    y = Q[1] * zinv % p
    return int.to_bytes(y | ((x & 1) << 255), 32, "little")


SECRET KEY:
9d61b19deffd5a60ba844af492ec2cc44449c5697b326919703bac031cae7f60
9d 61 b1 9d ef fd 5a 60 ba 84 4a f4 92 ec 2c c4 44 49 c5 69 7b 32 69 19 70 3b ac 03 1c ae 7f 60
0x9d, 0x61, 0xb1, 0x9d, 0xef, 0xfd, 0x5a, 0x60, 0xba, 0x84, 0x4a, 0xf4, 0x92, 0xec, 0x2c, 0xc4, 0x44, 0x49, 0xc5, 0x69, 0x7b, 0x32, 0x69, 0x19, 0x70, 0x3b, 0xac, 0x03, 0x1c, 0xae, 0x7f, 0x60

PUBLIC KEY:
d75a980182b10ab7d54bfed3c964073a0ee172f3daa62325af021a68f707511a

